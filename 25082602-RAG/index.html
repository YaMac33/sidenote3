<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>25.8.27 RAG（Retrieval-Augmented Generation）の解説</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles for better readability and aesthetics */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+JP:wght@400;500;700&display=swap');
        
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
            background-color: #f8fafc; /* slate-50 */
        }
        
        h1, h2, h3, h4 {
            font-weight: 700;
        }

        .code-block-container {
            position: relative;
            margin-top: 1rem;
            margin-bottom: 1rem;
        }

        .copy-button {
            position: absolute;
            top: 0.75rem;
            right: 0.75rem;
            padding: 0.25rem 0.75rem;
            border-radius: 0.375rem;
            background-color: #4a5568; /* gray-700 */
            color: white;
            font-size: 0.875rem;
            cursor: pointer;
            transition: background-color 0.2s;
            border: 1px solid #2d3748; /* gray-800 */
        }

        .copy-button:hover {
            background-color: #2d3748; /* gray-800 */
        }
        
        .copy-button.copied {
            background-color: #2f855a; /* green-700 */
        }

        pre {
            background-color: #1a202c; /* gray-900 */
            color: #e2e8f0; /* slate-200 */
            padding: 1.5rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        code {
            font-family: 'Menlo', 'Monaco', 'Consolas', "Courier New", monospace;
        }
        
        /* Inline code style */
        :not(pre) > code {
            background-color: #f1f5f9; /* slate-100 */
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.9em;
        }
        
        hr {
            border-color: #e2e8f0; /* slate-200 */
            margin-top: 2rem;
            margin-bottom: 2rem;
        }
    </style>
</head>
<body class="text-gray-800">

    <div class="container mx-auto p-4 sm:p-6 md:p-8 max-w-4xl">
        
        <header class="mb-8">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900">25.8.27 RAG（Retrieval-Augmented Generation）の解説</h1>
        </header>

        <main class="bg-white p-6 sm:p-8 rounded-lg shadow-md">
            
            <blockquote class="border-l-4 border-slate-300 pl-4 py-2 my-4 bg-slate-50 text-gray-700">
                <p class="font-semibold">「長い文脈が必要なら埋め込み検索で履歴を補完する「RAG」構成」について詳しく教えて。</p>
            </blockquote>
            
            <p class="mt-6 text-gray-700">以下「RAG（Retrieval-Augmented Generation：埋め込み検索を使って長い文脈を補完する構成）」について詳しく解説します。あなたの流れ（AIに質問→回答をデータベースへ保存→HTML化→VSCode/GitHub公開）にどう組み込むかも併せて提案します。</p>
            
            <hr>

            <!-- Section 1: What is RAG -->
            <section>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">1) RAGとは何か</h2>
                <h4 class="text-lg font-semibold mt-4 mb-2">基本 idea</h4>
                <p class="text-gray-700">LLM（大規模言語モデル）だけでなく、関連する外部文書や履歴を事前に検索して取り込み、その情報を元に回答を生成する構成です。</p>
                <h4 class="text-lg font-semibold mt-4 mb-2">なぜ有効か</h4>
                <p class="text-gray-700">LLMの文脈窓が有限で長い背景情報をそのまま保持できない場合でも、関連情報を取り出して「必要な分だけ」の文脈を追加して回答を作れるため、長文・専門的・最新情報の精度を高めやすい。</p>
                <h4 class="text-lg font-semibold mt-4 mb-2">使いどころ</h4>
                <p class="text-gray-700">企業知識ベース、FAQ・マニュアル、会話履歴、PDF/文書データ、Webサイトの知識などを統合して答えを出す場面。</p>
            </section>
            
            <hr>

            <!-- Section 2: Basic Components -->
            <section>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">2) RAGの基本構成要素</h2>
                <ul class="list-disc list-inside space-y-2 text-gray-700">
                    <li><strong>コンテンツ源（Knowledge Sources）:</strong> 企業内ドキュメント、データベース、過去のチャット履歴、ウェブ情報など。</li>
                    <li><strong>Embeddingモデル:</strong> 文章を高次元ベクトルに変換するモデル。例：OpenAIの <code>embeddings</code>、Sentence Transformers（BERT系）、など。</li>
                    <li><strong>ベクトルデータベース（Vector Store）:</strong> 埋め込みベクトルを格納・検索するDB。例：<code>Pinecone</code>、<code>Weaviate</code>、<code>Chroma</code>、<code>FAISS</code>（ローカル実装）。</li>
                    <li><strong>レトリーバ（Retriever）:</strong> クエリをベクトル化して、最も関連する文書をベクトルデータベースから取得する役割。</li>
                    <li><strong>ジェネレータ（Generator）:</strong> LLM（GPT-4/Claudeなど）を用いて、 retrieved context を組み込んだ最終回答を生成。</li>
                    <li><strong>オーケストレーター/フレームワーク:</strong> <code>LangChain</code>、<code>LlamaIndex</code>（現名: <code>gpt-index</code>）/ <code>Haystack</code> など、RAGの流れを組み立て、プロンプト設計・データ連携を管理。</li>
                </ul>
            </section>

            <hr>

            <!-- Section 3: Implementation Patterns -->
            <section>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">3) RAGの実装パターン</h2>
                <ul class="list-disc list-inside space-y-2 text-gray-700">
                    <li><strong>RAG-Token:</strong> 生成中の各トークン取得前に都度文書を検索して、生成を動的に補完。高精度だが複雑で遅くなることがある。</li>
                    <li><strong>RAG-Sequence:</strong> 事前に複数の文書を検索して全体の文脈を用意し、それを使って一括で回答を出す。比較的シンプルで高速化しやすい。</li>
                    <li><strong>ハイブリッド/ハイブリッド検索:</strong> キーワード検索と埋め込み検索を組み合わせ、まず候補を絞り、次にベクトル検索で精度を高める手法。</li>
                </ul>
            </section>

            <hr>

            <!-- Section 4: Practical Points -->
            <section>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">4) 実務的な実装のポイント</h2>
                <ul class="list-disc list-inside space-y-2 text-gray-700">
                    <li><strong>データ設計:</strong> knowledge sources: ドキュメントのメタデータ（カテゴリ、作成日、著者）を持たせ、検索結果の信頼性を示すメタ情報を返せるようにする。会話履歴は「現在の質問文＋関連履歴」を適切に混ぜて文脈を強化する。</li>
                    <li><strong>プロンプト設計:</strong> コンテキストの長さに制限があるため、 retrieved docs を要点ごとに要約して入れる工夫をする。検索結果の出典を明記させるプロンプトを入れて、回答の信頼性を担保する（Source: docX, docY など）。</li>
                    <li><strong>セキュリティ/プライバシー:</strong> 機密情報を外部APIへ送る場合はデータ暗号化・アクセス制御を徹底。必要ならオンプレミスのベクトルデータベースを検討。</li>
                    <li><strong>パフォーマンス:</strong> レスポンス遅延を許容する場合はキャッシュと再検索の閾値を設定。最新情報が必要な場合は定期的なインデックス更新を設計。</li>
                    <li><strong>コスト管理:</strong> embedding と LLM 呼び出しコストがかかるため、知識ベースを適切に要約・分割して、不要なデータを抑制。</li>
                </ul>
            </section>

            <hr>

            <!-- Section 5: Integration Plan -->
            <section>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">5) あなたの流れにRAGをどう組み込む具体案</h2>
                <h4 class="text-lg font-semibold mt-4 mb-2">全体の流れをRAG視点で再設計</h4>
                <ol class="list-decimal list-inside space-y-2 text-gray-700">
                    <li>ユーザーが「質問」を投げる。</li>
                    <li>クエリを embedding してベクトル化、ベクトルデータベースから top-K の関連ドキュメントを取得（履歴を含む場合は memory コレクションも検索対象に）。</li>
                    <li>取得した文書をプロンプトに組み込み、LLMに質問に対する回答を生成させる。必要なら出典も併せて返すよう指示。</li>
                    <li>生成結果をデータベースへ保存（質問、回答、参照した文書ID、タイムスタンプ、ユーザー情報など）。</li>
                    <li>必要なら、回答をHTML化のテンプレートへ渡してワンタッチHTMLを作成。HTML生成用のプロンプトをあらかじめ用意しておく。</li>
                    <li>HTMLをVSCode用のスニペット/ファイルとして出力、GitHubへ push、公開ワークフローへ連携。</li>
                </ol>

                <h4 class="text-lg font-semibold mt-4 mb-2">実装のおすすめスタック</h4>
                <ul class="list-disc list-inside space-y-2 text-gray-700">
                    <li><strong>LLM選択:</strong> OpenAI（<code>GPT-4</code>/<code>GPT-4o</code> など）や Claude、またはオープンソース系LLMを使う場合は適宜選択。機密性・コストを考慮して決定。</li>
                    <li><strong>Embeddingモデル:</strong> OpenAI <code>embeddings</code> か Sentence Transformers 系（例: <code>all-MiniLM-L6-v2</code> など）。OpenAIを使えば統一的に運用しやすいがコストに注意。</li>
                    <li><strong>Vector DB:</strong> <code>Pinecone</code>、<code>Weaviate</code>、<code>Chroma</code>（ローカル/オープンソース）、<code>FAISS</code>（自前実装）など。</li>
                    <li><strong>RAGフレームワーク:</strong> <code>LangChain</code>（Python） or <code>LlamaIndex</code>/<code>gpt-index</code>。プロンプトテンプレート・メモリ管理・データ連携を効率化。</li>
                    <li><strong>データストア:</strong> 質問・回答・メタデータを DB（<code>PostgreSQL</code>等）に保存。文書のバージョン管理は別処理で。</li>
                    <li><strong>HTML自動生成:</strong> 回答をHTML化するためのプロンプト（テンプレート）を用意。例: 「以下の回答を、アクセシビリティ考慮済みのHTMLに変換してください。見出し・段落・リスト・コードブロックを適切に配置。出典リンクを付与。」</li>
                    <li><strong>CI/CD・公開自動化:</strong> GitHub Actions で push → デプロイ → 公開までのパイプラインを作成。</li>
                </ul>

                <h4 class="text-lg font-semibold mt-4 mb-2">実装ステップのサマリ</h4>
                <ol class="list-decimal list-inside space-y-2 text-gray-700">
                    <li>知識ソースとメタデータ設計を決める。</li>
                    <li>EmbeddingモデルとベクトルDBを選定・セットアップ。</li>
                    <li>Retriever/LLMの組み合わせを決め、<code>LangChain</code>などでワークフローを構築。</li>
                    <li>質問→回答→DB保存の流れを実装。履歴を含む場合は memory/履歴ストアの検索を組み込む。</li>
                    <li>回答をHTML化するテンプレを実装。</li>
                    <li>VSCode/GitHub公開の自動化スクリプトを用意。</li>
                    <li>セキュリティ・監視・コスト管理の仕組みを整備。</li>
                </ol>
            </section>

            <hr>

            <!-- Section 6: Prompt Examples -->
            <section>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">6) 実践的なプロンプトの例（参考）</h2>
                
                <h4 class="text-lg font-semibold mt-4 mb-2">RAG 質問回答用（日本語）</h4>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
<pre><code>システムプロンプト: あなたは企業内ナレッジアシスタントです。以下の文書を参照して、質問に対して根拠のある回答を作成します。出典を必ず併記してください。
ユーザーの問: {user_question}
コンテキスト（ retrieved_docs から要約を入れる）:
回答フォーマット例: 回答本文。出典: doc1, doc3 など。</code></pre>
                </div>
                
                <h4 class="text-lg font-semibold mt-4 mb-2">HTML化用プロンプト</h4>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
<pre><code>入力: 回答テキストと任意のデザイン要件（ブランドカラー、フォント、ヘッダ構成など）。
出力: 完全なHTMLスニペット（見出し、段落、リスト、画像プレースホルダ、基本的なCSS）。</code></pre>
                </div>

                <h4 class="text-lg font-semibold mt-4 mb-2">HTMLをVSCode/GitHubへ渡すための補助</h4>
                <div class="code-block-container">
                    <button class="copy-button" onclick="copyCode(this)">Copy</button>
<pre><code>「HTMLファイル名は answer-YYYYMMDD.html、ディレクトリは /docs、READMEにビルド手順を追記」などのファイル命名ルールをプロンプトに組み込む。</code></pre>
                </div>
            </section>

            <hr>

            <!-- Section 7: Best Practices -->
            <section>
                <h2 class="text-2xl font-semibold border-b pb-2 mb-4">7) 小さな注意点・ベストプラクティス</h2>
                <ul class="list-disc list-inside space-y-2 text-gray-700">
                    <li><strong>出典と信頼性の表示:</strong> 可能なら回答に出典を付ける設計にして、ユーザーが参照元を追えるようにする。</li>
                    <li><strong>プライバシー設計</strong></li>
                </ul>
            </section>
        </main>
    </div>

    <script>
        function copyCode(button) {
            const codeBlockContainer = button.parentElement;
            const codeElement = codeBlockContainer.querySelector('code');
            
            if (codeElement) {
                const textArea = document.createElement('textarea');
                textArea.value = codeElement.innerText;
                
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                
                textArea.select();
                try {
                    document.execCommand('copy');
                    button.textContent = 'Copied!';
                    button.classList.add('copied');
                    
                    setTimeout(() => {
                        button.textContent = 'Copy';
                        button.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy text: ', err);
                    button.textContent = 'Error';
                }
                
                document.body.removeChild(textArea);
            }
        }
    </script>

</body>
</html>
