<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>25.8.25 プロンプト保存と翻訳の自動化</title>
<style>
:root{
  --bg:#f4f7fb; --card:#fff; --ink:#0f1724; --muted:#64748b;
  --accent:#2563eb; --ok:#16a34a; --warn:#f59e0b; --code-bg:#0b1220; --code-fg:#e6eef8;
  --border:#e6eef7;
}
*{box-sizing:border-box}
body{font-family: "Noto Sans JP", system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  margin:0; background:var(--bg); color:var(--ink); line-height:1.7;}
.header{background:linear-gradient(90deg,#2563eb,#60a5fa); color:white; padding:18px 20px}
.header h1{margin:0;font-size:1.15rem}
.container{max-width:980px;margin:22px auto;padding:0 16px}
.card{background:var(--card); border:1px solid var(--border); border-radius:12px; padding:20px; box-shadow:0 6px 20px rgba(16,24,40,.05); margin-bottom:16px}
.hint{color:var(--muted); font-size:.95rem}
.row{display:flex; gap:12px; flex-wrap:wrap}
.col{flex:1 1 0}
h2{margin:.1rem 0 8px; color:var(--accent)}
h3{margin:.6rem 0 6px; color:#0b2b52}
kbd{background:#eef2ff;border:1px solid #dbeafe;padding:3px 6px;border-radius:6px;font-family:ui-monospace,monospace}
.small{font-size:.92rem;color:var(--muted)}
ul{margin:0 0 8px 20px}
ol{margin:0 0 8px 20px}
table{width:100%; border-collapse:collapse; margin:8px 0}
th,td{border:1px solid #e6eef7;padding:8px;text-align:left}
th{background:#f1f8ff}
pre{background:var(--code-bg); color:var(--code-fg); padding:12px; border-radius:10px; overflow:auto; position:relative}
.copybtn{position:absolute; right:10px; top:8px; background:var(--accent); color:white; border:none; padding:6px 8px; border-radius:8px; cursor:pointer; font-size:.9rem}
.pill{display:inline-block;padding:4px 10px;border-radius:999px;border:1px solid #e6eef7;background:#fbfdff;font-size:.9rem}
.callout{border-left:4px solid var(--ok); background:#f0fdf4;padding:10px;border-radius:8px;margin:10px 0}
.warn{border-left:4px solid var(--warn); background:#fff7ed;padding:10px;border-radius:8px}
.footer{color:var(--muted); text-align:center; padding:18px 10px}
.small-note{font-size:.92rem;color:var(--muted);margin-top:8px}
</style>
</head>
<body>

<div class="header"><h1>25.8.25 プロンプト保存と翻訳の自動化</h1></div>

<div class="container">

  <!-- Prompt -->
  <section class="card">
    <h2>あなた（プロンプト）</h2>
    <p class="hint">将来的に作りたい仕組み — 要件をそのまま記載</p>
    <div class="small">
      <strong>要旨：</strong>プロンプトを書き込むと通常どおりAIが回答し、同時に日本語版を1つのデータベースへ、英訳したプロンプトと英訳した回答を別のデータベースへ自動で保存。両DBにタイムスタンプを付与。最初は個人用プロトタイプ、将来的にはマルチユーザー対応に移行したい。
    </div>
  </section>

  <!-- AI Response / Manual -->
  <section class="card">
    <h2>AI（回答・マニュアル化）</h2>

    <h3>結論（推奨アプローチ）</h3>
    <p class="small">まずは <strong>Googleスプレッドシート + Google Apps Script (GAS)</strong> で最小プロトタイプを作り、将来的に <strong>Supabase / Airtable / PostgreSQL</strong> へ移行する流れがおすすめです。</p>

    <div class="callout">
      <strong>理由：</strong>
      <ul>
        <li>GASはブラウザだけで完結 → 素早く検証できる。</li>
        <li>Googleスプレッドシートは簡単にAPI連携・翻訳関数の活用が可能。</li>
        <li>データ量やマルチユーザー要件が増えたらSupabase等へ移行しやすい。</li>
      </ul>
    </div>

    <h3>設計方針（段階別）</h3>
    <ol>
      <li><strong>Step1（個人プロトタイプ）</strong><br>
        Googleスプレッドシート（日本語シート・英語シート） + GAS。プロンプト送信 → ChatGPT APIで回答取得 → 翻訳API（DeepL/OpenAI）で英訳 → それぞれのシートにタイムスタンプ付きで保存。
      </li>
      <li><strong>Step2（見た目＆管理）</strong><br>
        Notionへ同期または移行してUI/フィルタを整える（Notionは表示・閲覧が見やすい）。
      </li>
      <li><strong>Step3（本格運用）</strong><br>
        Supabase/Airtable/PostgresでDB化、Webアプリ（React/Next.js + Flask/FastAPI）を構築してマルチユーザー対応に移行。
      </li>
    </ol>

    <h3>最小構成（推奨ワークフロー）</h3>
    <ol>
      <li>ユーザーがフォームへプロンプトを入力（GASのWebアプリ or 自作UI）</li>
      <li>サーバー or GAS で ChatGPT API を呼ぶ → 回答（日本語）を取得</li>
      <li>翻訳API（DeepL or OpenAI）で prompt & response を英訳</li>
      <li>日本語は <em>Sheet: prompts_ja</em>、英語は <em>Sheet: prompts_en</em> に保存（タイムスタンプ付き）</li>
      <li>必要なら Notion / Webアプリに同期・表示</li>
    </ol>

    <h3>DB 選択のメリット/デメリット（要約）</h3>
    <table>
      <tr><th>選択肢</th><th>長所</th><th>短所</th></tr>
      <tr><td>Googleスプレッドシート</td><td>導入/実装が簡単。GASで完結。関数で翻訳可。</td><td>リッチテキスト弱い。共有設定に注意。</td></tr>
      <tr><td>Notion</td><td>UIが綺麗。データ閲覧が楽。</td><td>大量データや高速検索は苦手。APIレート注意。</td></tr>
      <tr><td>Supabase / Postgres</td><td>大量データ・認証・高速検索に強い。将来性◎</td><td>実装コストが上がる（UI作成が必要）。</td></tr>
    </table>

  </section>

  <!-- Implementation: GAS sample -->
  <section class="card">
    <h2>Step1 実装例：Google Apps Script（GAS）でクラウド完結</h2>
    <p class="small">以下は動作イメージの「完成形サンプル」。Webアプリ化するとブラウザから入力でき、プロンプト→回答→英訳→両シートへ保存が自動で行われます。</p>

    <h3>GAS 完全サンプル（コピーして使えます）</h3>
    <pre id="code-gas"><button class="copybtn" onclick="copyCode('code-gas')">コピー</button><code>// Google Apps Script (GAS) — 完全サンプル
// 事前準備: スプレッドシートに2つのシートを用意する
// シート名: "prompts_ja" (Timestamp, Prompt_JA, Response_JA)
//         : "prompts_en" (Timestamp, Prompt_EN, Response_EN)

// トリガー: このスクリプトはWebアプリ (doPost) として公開する想定です。
// 1) プロンプトを POST で送ると、ChatGPT APIに問い合わせ、英訳し、両シートに書き込みます。

const OPENAI_API_KEY = 'YOUR_OPENAI_API_KEY'; // secretsに保存が望ましい
const SHEET_ID = 'YOUR_SPREADSHEET_ID_HERE';

function doPost(e){
  const payload = JSON.parse(e.postData.contents);
  const prompt = payload.prompt || '';
  if(!prompt) return ContentService.createTextOutput(JSON.stringify({error:'no prompt'})).setMimeType(ContentService.MimeType.JSON);

  // 1) ChatGPT に問い合わせ（例: OpenAI ChatCompletion）
  const responseJA = callChatGPT(prompt);

  // 2) 英訳 (ここでは OpenAI を使って英訳。ただし DeepL に置き換えてOK)
  const promptEN = translateToEnglish(prompt);
  const responseEN = translateToEnglish(responseJA);

  // 3) スプレッドシートに保存
  saveToSheets(prompt, responseJA, promptEN, responseEN);

  return ContentService.createTextOutput(JSON.stringify({ok:true, response: responseJA})).setMimeType(ContentService.MimeType.JSON);
}

function callChatGPT(prompt){
  const url = 'https://api.openai.com/v1/chat/completions';
  const payload = {
    model: 'gpt-4o-mini', // 環境に合わせて変更
    messages: [{role:'user', content: prompt}],
    max_tokens: 800
  };
  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: { Authorization: 'Bearer ' + OPENAI_API_KEY },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  const res = UrlFetchApp.fetch(url, options);
  const json = JSON.parse(res.getContentText());
  // レスポンス構造に合わせて取得
  const text = json.choices && json.choices[0] && json.choices[0].message ? json.choices[0].message.content : '';
  return text;
}

function translateToEnglish(text){
  // 単純に OpenAI に翻訳させる例
  const url = 'https://api.openai.com/v1/chat/completions';
  const payload = {
    model: 'gpt-4o-mini',
    messages: [
      {role:'system', content:'You are a translation assistant. Translate Japanese to natural English.'},
      {role:'user', content: text}
    ],
    max_tokens: 500
  };
  const options = {
    method: 'post',
    contentType: 'application/json',
    headers: { Authorization: 'Bearer ' + OPENAI_API_KEY },
    payload: JSON.stringify(payload),
    muteHttpExceptions: true
  };
  const res = UrlFetchApp.fetch(url, options);
  const json = JSON.parse(res.getContentText());
  return json.choices && json.choices[0] && json.choices[0].message ? json.choices[0].message.content : '';
}

function saveToSheets(promptJA, responseJA, promptEN, responseEN){
  const ss = SpreadsheetApp.openById(SHEET_ID);
  const shJA = ss.getSheetByName('prompts_ja') || ss.insertSheet('prompts_ja');
  const shEN = ss.getSheetByName('prompts_en') || ss.insertSheet('prompts_en');
  const now = new Date();
  shJA.appendRow([now, promptJA, responseJA]);
  shEN.appendRow([now, promptEN, responseEN]);
}</code></pre>

    <div class="small-note">※ <strong>注意：</strong>APIキーはスクリプトプロパティやGCP Secret Managerに格納し、コード内に直書きしないことを推奨します。</div>

  </section>

  <!-- Flask + gspread sample -->
  <section class="card">
    <h2>Step2: 将来の移行イメージ（Flask + gspread / Supabase）</h2>
    <p class="small">ローカル/サーバーで動かす場合のサンプル（Flask + gspreadでGoogleスプレッドシートに保存）</p>

    <h3>Flask: 最小API（app.py）</h3>
    <pre id="code-flask"><button class="copybtn" onclick="copyCode('code-flask')">コピー</button><code># app.py (最小)
from flask import Flask, request, jsonify
import requests
import os
import gspread
from oauth2client.service_account import ServiceAccountCredentials
from datetime import datetime

app = Flask(__name__)
OPENAI_KEY = os.getenv('OPENAI_API_KEY')
SHEET_ID = os.getenv('GOOGLE_SHEET_ID')
# gspread 認証
scope = ['https://spreadsheets.google.com/feeds','https://www.googleapis.com/auth/drive']
creds = ServiceAccountCredentials.from_json_keyfile_name('service_account.json', scope)
gc = gspread.authorize(creds)
sh = gc.open_by_key(SHEET_ID)

def call_chatgpt(prompt):
    url = 'https://api.openai.com/v1/chat/completions'
    payload = {"model":"gpt-4o-mini","messages":[{"role":"user","content":prompt}]}
    headers = {"Authorization": f"Bearer {OPENAI_KEY}"}
    r = requests.post(url, json=payload, headers=headers)
    return r.json()['choices'][0]['message']['content']

def translate_to_en(text):
    # 簡易: ChatGPTで翻訳
    return call_chatgpt("Translate to English: " + text)

@app.route('/api/send', methods=['POST'])
def send():
    data = request.json
    prompt = data.get('prompt','')
    response_ja = call_chatgpt(prompt)
    prompt_en = translate_to_en(prompt)
    response_en = translate_to_en(response_ja)
    now = datetime.utcnow().isoformat()
    sh.worksheet('prompts_ja').append_row([now, prompt, response_ja])
    sh.worksheet('prompts_en').append_row([now, prompt_en, response_en])
    return jsonify({'ok':True, 'response': response_ja})

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8000)</code></pre>

    <div class="small-note">この構成は、将来的にSupabase/Postgresへ置き換えやユーザー認証（JWT / Supabase Auth）を導入する流れにスムーズに移行できます。</div>
  </section>

  <!-- UI notes -->
  <section class="card">
    <h2>UI（ChatGPT風にするためのポイント）</h2>
    <ul>
      <li>サイドバー：ルーム一覧（room_id, title, last_updated）</li>
      <li>メイン：メッセージリスト（role別のバブル表示）</li>
      <li>送信：送信ボタンで /api/rooms/{id}/messages に POST</li>
      <li>即時表示： optimistic UI（レスポンスを待たずに送信メッセージを一時表示）</li>
    </ul>

    <h3>フロントから送信する簡易Fetch例</h3>
    <pre id="code-fetch"><button class="copybtn" onclick="copyCode('code-fetch')">コピー</button><code>// fetch 例（フロント）
async function sendPrompt(prompt){
  const res = await fetch('/api/send', {
    method: 'POST',
    headers: {'Content-Type':'application/json'},
    body: JSON.stringify({prompt})
  });
  const data = await res.json();
  return data.response;
}</code></pre>
  </section>

  <!-- Decision & next steps -->
  <section class="card">
    <h2>次のアクション（推奨）</h2>
    <ol>
      <li>まずはGASのサンプルを試して、動作確認（数時間で完了可能）</li>
      <li>動いたらFlask版を作成して、UIをChatGPT風に整える（パフォーマンス向上）</li>
      <li>そこからSupabase等にDBを移行し、ユーザー認証を追加してマルチユーザー対応へ</li>
    </ol>

    <div class="warn">
      <strong>注意：</strong>APIキーやサービスアカウントJSONは絶対に公開リポジトリに置かないでください。開発中でも秘密情報の管理を徹底してください。
    </div>

    <h3>どのコードを出しますか？（今すぐ作るサンプル）</h3>
    <p class="small">選択肢： (1) GAS 完成形コード (上記) ／ (2) Flask 最小実装 (上記) ／ (3) 両方＋フロントの簡易テンプレート</p>
  </section>

  <div class="footer">作業のサポートが必要なら、希望のサンプル（GAS or Flask or both）を教えてください。</div>

</div>

<script>
  // copy helper: id of pre
  function copyCode(id){
    const pre = document.getElementById(id) || document.getElementById(id) || document.querySelector('#'+id);
    let text;
    if(pre){
      // if invoked with id string like 'code-gas', pre is element
      text = pre.innerText;
    } else {
      // fallback for buttons that pass element id via event
      return;
    }
    navigator.clipboard.writeText(text).then(()=>{
      // find the button inside the pre and show feedback
      // simple feedback via alert avoided; we change button text temporarily
      const btns = document.querySelectorAll('.copybtn');
      btns.forEach(b=>{
        if(b){ b.textContent = 'コピーしました'; setTimeout(()=>b.textContent='コピー',1400); }
      });
    }).catch(()=>{ alert('コピーに失敗しました。手動で選択してください。'); });
  }

  // also support buttons inside pre w/o id: direct sibling copy
  document.querySelectorAll('pre').forEach(p=>{
    const btn = p.querySelector('.copybtn');
    if(btn){
      btn.addEventListener('click', ()=> {
        const txt = p.innerText;
        navigator.clipboard.writeText(txt).then(()=>{
          const original = btn.textContent;
          btn.textContent = 'コピーしました';
          setTimeout(()=>btn.textContent = original, 1400);
        }).catch(()=>{ alert('コピー失敗'); });
      });
    }
  });
</script>

</body>
</html>
